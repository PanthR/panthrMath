(function(define) {'use strict';
define(function(require) {

   var utils, log1p;

   log1p = require('./basicFunc/log1p').log1p;

   utils = {
      /* mixin */
      mixin: function mixin(target) {
         Array.prototype.slice.call(arguments, 1)
            .forEach(function(source) {
               Object.keys(source).forEach(function(key) {
                  target[key] = source[key];
               });
            });
         return target;
      },
      /* Maximum number of steps for `repeat` iterations. */
      maxSteps: 1000,
      /* repeat, for carrying out repeated improvement until stopping
       * condition is satisfied, or until `utils.maxSteps` have been
       * performed.
       *
       * `init` is the initial value,
       * `step` is a function which returns the new value, and
       * `stop` is a non-negative integer (number of steps to take),
       *  a function of no arguments returning a boolean, or missing.
       *  If `stop` is omitted, the default behavior is using
       * `utils.relativelyCloseTo`.
       *  Iteration will stop after `utils.maxSteps`, regardless.
       */
      repeat: function(init, step, stop) {
         var prev, curr, done, reps;
         curr = init;
         reps = utils.maxSteps;
         if (stop === 0) { return curr; }
         done = typeof stop === 'function' ? stop :
                stop > 0 ? function() { stop -= 1; return stop === 0; } :
                        function() { return utils.relativelyCloseTo(curr, prev); };
         while (reps > 0 && !done() && !isNaN(curr)) {
            reps -= 1;
            prev = curr;
            curr = step();
         }
         if (isNaN(curr)) { console.log('repeat returned NaN'); }
         if (reps === 0) {
            console.log('repeat terminated after too many repetitions');
         }
         return curr;
      },
      /* series
       * - `f` is a function two arguments, `index` and `prev` (previous
       *     value).  It will be called starting at `index` 0.
       * - `stop` is the same as in `repeat`.
       * Add up the terms generated by `f` for index >= 0; stopping conditions
       * are the same as for `repeat`.
       */
      series: function(f, stop) {
         var sum, curr, i;
         i = 0;
         curr = f(0);
         sum = curr;
         return utils.repeat(sum, function() {
            i += 1;
            curr = f(i, curr);
            sum += curr;
            return sum;
         }, stop);
      },
      /* precision used by relativelyCloseTo */
      precision: 1e-10,
      /* relativelyCloseTo returns a boolean indicating whether x, x0 are
       * relatively close to each other as specified by the precision `delta`.
       * If `delta` is not provided, `utils.precision` is used instead.
       *
       * Special cases for NaN, Infinity, -Infinity
       */
      relativelyCloseTo: function(x, x0, delta) {
         delta = delta || utils.precision;
         var absMax = Math.max(Math.abs(x0), Math.abs(x));
         if (isNaN(absMax)) { return isNaN(x) && isNaN(x0); } /* both NaN */
         if (absMax === Infinity) { return x0 === x; }
         if (absMax === 0) { return true; }
         return Math.abs(x - x0) / absMax < delta;
      },
      /* contFrac
       * A continued fraction has the form
       * a0 + (b1 / (a1 + (b2 / (a2 + ...)))
       * where a is indexed from 0 and b is indexed from 1.    *
       * - `a` and `b` are functions with parameters `i` and `v` for generating
       * the ai and bi sequences; each time, the function returns the ith term
       * of the sequence based on the previous value, `v`.
       * - `stop` is the same as in `repeat`.
       *
       * Return a value for the indicated continued fraction, to a precision
       * as determined by `stop`.
       */
      contFrac: function(a, b, stop) {
         var A, A1, A2; // A2 is "two previous" to A, A1 is "one previous"
         var B, B1, B2, an, bn, i;
         an = a(0);
         A = an;
         A1 = 1;
         bn = 1;
         B = bn;
         B1 = 0;
         i = 0;
         return utils.repeat(A / B, function() {
            A2 = A1;
            A1 = A;
            B2 = B1;
            B1 = B;
            i += 1;
            an = a(i, an);
            bn = b(i, bn);
            A = A1 * an + A2 * bn;
            B = B1 * an + B2 * bn;
            return A / B;
         }, stop);
      },
      /*
       * If lx = log(x), ly = log(y), calculates log(x + y)
       */
      logspaceAdd: function(lx, ly) {
          return Math.max(lx, ly) + log1p(Math.exp(-Math.abs(lx - ly)));
      }
   };

   return utils;

});

}(typeof define === 'function' && define.amd ? define : function(factory) {
   'use strict';
   module.exports = factory(require);
}));
